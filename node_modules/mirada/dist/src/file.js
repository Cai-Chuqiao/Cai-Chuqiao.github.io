"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("assert");
var cross_fetch_1 = __importDefault(require("cross-fetch"));
var misc_utils_of_mine_generic_1 = require("misc-utils-of-mine-generic");
var imageCreation_1 = require("./browser/imageCreation");
var format_1 = require("./format");
var base64_1 = require("./util/base64");
var fileUtil_1 = require("./util/fileUtil");
var imageUtil_1 = require("./util/imageUtil");
var fileType = require("file-type");
/**
 * A thin layer on top of cv.Mat with lots of utilities to load, write, encode, etc.
 */
var File = /** @class */ (function () {
    function File(name, _mat) {
        this.name = name;
        this._mat = _mat;
    }
    File.prototype.size = function () {
        return {
            width: this._mat.cols,
            height: this._mat.rows
        };
    };
    File.prototype.getMimeType = function () {
        return misc_utils_of_mine_generic_1.getMimeTypeForExtension(this.getExtension());
    };
    File.prototype.getExtension = function () {
        return misc_utils_of_mine_generic_1.getFileExtension(this.name).toLowerCase();
    };
    File.prototype.asMat = function () {
        return this._mat;
    };
    File.prototype.asImageData = function () {
        return imageUtil_1.toImageData(this._mat);
    };
    File.prototype.asHTMLImageData = function () {
        return imageCreation_1.asHtmlImageData(this._mat);
    };
    File.prototype.asDataUrl = function () {
        return 'data:' + this.getMimeType() + ';' + this.name + ';base64,' + this.asBase64();
    };
    Object.defineProperty(File.prototype, "width", {
        get: function () {
            return this._mat.cols;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "height", {
        get: function () {
            return this._mat.rows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(File.prototype, "mat", {
        get: function () {
            return this._mat;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * It removes the the file from file system and also delete() this file's Mat
     */
    File.prototype.remove = function (deleteMat) {
        if (deleteMat === void 0) { deleteMat = true; }
        deleteMat && this.delete();
        this.name && fileUtil_1.isFile(this.name) && fileUtil_1.removeFile(this.name);
        return this;
    };
    /**
     * Returns an array buffer containing the image encoded in given format or inferring format from its name.
     */
    File.prototype.asArrayBuffer = function (format) {
        if (format === void 0) { format = this.getExtension(); }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, format_1.encodeOrThrow(this.asImageData(), format)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Writes this image on given file path, encoded in given format (or inferred form current name).
     */
    File.prototype.write = function (path, format) {
        if (path === void 0) { path = this.name; }
        if (format === void 0) { format = this.getExtension(); }
        return __awaiter(this, void 0, void 0, function () {
            var a;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.asArrayBuffer(format)];
                    case 1:
                        a = _a.sent();
                        fileUtil_1.writeFile(path, new Uint8ClampedArray(a));
                        return [2 /*return*/, this];
                }
            });
        });
    };
    File.prototype.setMat = function (mat) {
        this.delete();
        this._mat = mat;
        return this;
    };
    /**
     * Shows this image in given HTML canvas or image element.
     */
    File.prototype.show = function (el) {
        cv.imshow(el, this.asMat());
        return this;
    };
    File.prototype.asBase64 = function (format) {
        if (format === void 0) { format = this.getExtension(); }
        return __awaiter(this, void 0, void 0, function () {
            var encoded;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.asArrayBuffer(format)];
                    case 1:
                        encoded = _a.sent();
                        return [2 /*return*/, base64_1.arrayBufferToBase64(encoded)];
                }
            });
        });
    };
    File.prototype.delete = function () {
        try {
            this._mat && this._mat.delete();
        }
        catch (error) {
        }
    };
    /**
     * Converts the Mat of this file to RGBA channel type. It will replace the current mat and delete the original.
     */
    File.prototype.toRgba = function () {
        var dst = imageUtil_1.toRgba(this.mat);
        this.mat.delete();
        this._mat = dst;
        return this;
    };
    File.prototype.clone = function (name) {
        if (name === void 0) { name = this.name; }
        return File.fromMat(this.mat.clone(), name);
    };
    /**
     * Loads file from given base64 string containing an encoded image.
    */
    File.fromBase64 = function (base64, name) {
        var buffer = Buffer.from(base64, 'base64');
        return File.fromArrayBuffer(buffer, name || File.getBufferFileName(buffer));
    };
    /**
     * Loads file from given array buffer containing an encoded image.
     */
    File.fromArrayBuffer = function (buffer, name) {
        return __awaiter(this, void 0, void 0, function () {
            var format, data, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        name = name || File.getBufferFileName(buffer);
                        format = misc_utils_of_mine_generic_1.getFileExtension(name);
                        return [4 /*yield*/, format_1.decodeOrThrow(buffer, format)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, File.fromData(data, name)];
                    case 2:
                        error_1 = _a.sent();
                        console.error(error_1);
                        throw error_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Loads file from given array buffer view containing an encoded image.
     */
    File.fromArrayBufferView = function (a, name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, File.fromArrayBuffer(a.buffer, name)];
            });
        });
    };
    File.getBufferFileType = function (a) {
        var t = File.fileType(a);
        if (!t) {
            throw new Error('Could not get file type for buffer');
        }
        return t;
    };
    File.fileType = function (a) {
        var t = fileType(a);
        if (!t) {
            var s = base64_1.arrayBufferToString(a);
            if (s.includes('<svg')) {
                t = {
                    ext: 'svg',
                    mime: 'image/svg+xml'
                };
            }
        }
        return t;
    };
    File.getBufferFileName = function (a) {
        var t = File.getBufferFileType(a);
        return misc_utils_of_mine_generic_1.unique('file') + t.ext;
    };
    /**
     * Loads file from given data url string containing an encoded image.
    */
    File.fromDataUrl = function (dataUrl, name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, File.fromBase64(base64_1.urlToBase64(dataUrl), name)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Loads files from files in html input element of type "file".
     */
    File.fromHtmlFileInputElement = function (el) {
        var _this = this;
        if (!misc_utils_of_mine_generic_1.inBrowser()) {
            throw new Error('This method is only supported in the browser');
        }
        return Promise.all(Array.from(el.files).map(function (file) { return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.addEventListener('loadend', function (e) { return __awaiter(_this, void 0, void 0, function () { var _a; return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = resolve;
                        return [4 /*yield*/, File.fromArrayBuffer(reader.result, file.name)];
                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                }
            }); }); });
            reader.readAsArrayBuffer(file);
        }); }));
    };
    /**
     * Loads file form existing HTMLElement or HTMLImageElement
     */
    File.fromCanvas = function (el) {
        if (!misc_utils_of_mine_generic_1.inBrowser()) {
            throw new Error('This method is only supported in the browser');
        }
        return File.fromMat(cv.imread(el));
    };
    /**
     * Shortcut for [resolve] that returns the first result.
     */
    File.resolveOne = function (files) {
        return __awaiter(this, void 0, void 0, function () {
            var a;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, File.resolve(files)];
                    case 1:
                        a = _a.sent();
                        return [2 /*return*/, a.length > 0 ? a[0] : undefined];
                }
            });
        });
    };
    /**
     * Given paths, urls or files it will try to load them all and return a list of File for those succeed.
     */
    File.resolve = function (files) {
        return __awaiter(this, void 0, void 0, function () {
            var a, result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        a = misc_utils_of_mine_generic_1.asArray(files || []).filter(misc_utils_of_mine_generic_1.notUndefined);
                        return [4 /*yield*/, misc_utils_of_mine_generic_1.serial(a.map(function (f) { return function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (!(typeof f === 'string')) return [3 /*break*/, 5];
                                            if (!fileUtil_1.isFile(f)) return [3 /*break*/, 2];
                                            return [4 /*yield*/, File.fromFile(f)];
                                        case 1: return [2 /*return*/, _a.sent()];
                                        case 2: return [4 /*yield*/, File.fromUrl(f)];
                                        case 3: return [2 /*return*/, _a.sent()];
                                        case 4: return [3 /*break*/, 6];
                                        case 5:
                                            assert_1.ok(ArrayBuffer.isView(f._mat.data.buffer));
                                            return [2 /*return*/, f];
                                        case 6: return [2 /*return*/];
                                    }
                                });
                            }); }; }))];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.filter(misc_utils_of_mine_generic_1.notUndefined)];
                }
            });
        });
    };
    File.isFile = function (f) {
        return !!f && !!f.name && !!f._mat && !!f._mat.data &&
            typeof f.constructor !== 'undefined' && !!f.asImageData && !!f.asMat;
    };
    File.asPath = function (f) {
        return typeof f === 'string' ? f : f.name;
    };
    File.fromData = function (data, name) {
        return new File(File._buildName(name), cv.matFromImageData(data));
    };
    File._buildName = function (name) {
        return name || misc_utils_of_mine_generic_1.unique('file') + '.png';
    };
    File.fromMat = function (mat, name) {
        return new File(File._buildName(name), mat);
    };
    File.prototype.toString = function () {
        return "[File \"" + this.name + "\"]";
    };
    File.fromUrl = function (url, o) {
        if (o === void 0) { o = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var p, response, buffer, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        p = format_1.getDefaultCodec();
                        return [4 /*yield*/, cross_fetch_1.default(url)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.arrayBuffer()];
                    case 2:
                        buffer = _a.sent();
                        return [4 /*yield*/, format_1.decodeOrThrow(buffer)];
                    case 3:
                        data = _a.sent();
                        return [2 /*return*/, File.fromData(data, o.name || misc_utils_of_mine_generic_1.getFileNameFromUrl(url))];
                }
            });
        });
    };
    File.fromFile = function (path, name) {
        if (name === void 0) { name = misc_utils_of_mine_generic_1.basename(path); }
        return __awaiter(this, void 0, void 0, function () {
            var data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, format_1.decodeOrThrow(fileUtil_1.readFile(path).buffer)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, File.fromData(data, name)];
                }
            });
        });
    };
    return File;
}());
exports.File = File;
//# sourceMappingURL=file.js.map