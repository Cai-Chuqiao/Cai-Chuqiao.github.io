"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
/**
Usage example:

```js
const video = document.querySelector<HTMLVideoElement>('video')!
const canvas = document.querySelector<HTMLCanvasElement>('canvas')!;
try {
const FPS = 30
await loadOpencv()
const c = new VideoReader(video, canvas)
await c.canPlay()
const src = c.mat // read only!
const dst = new cv.Mat(src.rows, src.cols, cv.CV_8UC1)
const process = () => {
  let t0 = now()
  c.read() // reads video frame on src
  cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY)
  cv.imshow(canvas, dst)
  let delay = 1000 / FPS - msFrom(t0)
  setTimeout(process, delay)
}
process()
} catch (error) {
  console.log('navigator.MediaDevices.getUserMedia error: ', error.message, error.name);
  console.trace(error)
}
```

 */
var VideoReader = /** @class */ (function () {
    function VideoReader(video, canvas, o) {
        if (o === void 0) { o = VideoReader.defaultOptions; }
        this.video = video;
        this.canvas = canvas;
        this.o = o;
        this.mat = null;
        /**
         * Indicates if the video is currently being processed
         */
        this.streaming = false;
        this.o = __assign(__assign({}, VideoReader.defaultOptions), o);
        this.ctx = canvas.getContext('2d');
        this.size = this.getSize();
    }
    /**
     * reads current video frame into [mat]
     */
    VideoReader.prototype.read = function () {
        this.o.noMatCheck || this.matCheck();
        this.ctx.drawImage(this.video, 0, 0, this.size.width, this.size.height);
        this.mat.data.set(this.ctx.getImageData(0, 0, this.size.width, this.size.height).data);
    };
    VideoReader.prototype.canPlay = function () {
        var _this = this;
        var constraints = {
            audio: false,
            video: true
        };
        return new Promise(function (resolve) {
            _this.video.addEventListener('canplay', function () {
                var size = _this.getSize();
                _this.canvas.width = size.width;
                _this.canvas.height = size.height;
                _this.mat = new cv.Mat(size.height, size.width, cv.CV_8UC4);
                _this.streaming = true;
                resolve();
            }, false);
            navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
                _this.stream = _this.video.srcObject = stream;
            });
        });
    };
    VideoReader.prototype.stop = function () {
        if (this.stream) {
            this.stream.getVideoTracks().forEach(function (t) { return t.stop(); });
            this.streaming = false;
            util_1.del(this.mat);
        }
    };
    VideoReader.prototype.getSize = function () {
        if (!this.size) {
            this.size = this.o.size === 'videoSize' ? {
                width: this.video.videoWidth,
                height: this.video.videoHeight
            } : this.o.size === 'video' ? {
                width: this.video.width,
                height: this.video.height
            } : {
                width: this.canvas.width,
                height: this.canvas.height
            };
        }
        return this.size;
    };
    VideoReader.prototype.matCheck = function () {
        if (!(this.mat instanceof cv.Mat)) {
            throw new Error('Please input the valid cv.Mat instance.');
        }
        if (this.mat.type() !== cv.CV_8UC4) {
            throw new Error('Bad type of input mat: the type should be cv.CV_8UC4.');
        }
        if (this.mat.cols !== this.size.width || this.mat.rows !== this.size.height) {
            throw new Error('Bad size of input mat: the size should be same as the video.');
        }
    };
    VideoReader.defaultOptions = {
        size: 'canvas',
        constraints: {
            audio: false,
            video: true
        }
    };
    return VideoReader;
}());
exports.VideoReader = VideoReader;
//# sourceMappingURL=videoReader.js.map