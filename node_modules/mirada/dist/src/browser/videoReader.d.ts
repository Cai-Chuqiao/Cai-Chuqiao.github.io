import { Mat, Size } from '..';
interface Options {
    size?: 'videoSize' | 'video' | 'canvas';
    noMatCheck?: boolean;
    constraints?: MediaStreamConstraints;
}
/**
Usage example:

```js
const video = document.querySelector<HTMLVideoElement>('video')!
const canvas = document.querySelector<HTMLCanvasElement>('canvas')!;
try {
const FPS = 30
await loadOpencv()
const c = new VideoReader(video, canvas)
await c.canPlay()
const src = c.mat // read only!
const dst = new cv.Mat(src.rows, src.cols, cv.CV_8UC1)
const process = () => {
  let t0 = now()
  c.read() // reads video frame on src
  cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY)
  cv.imshow(canvas, dst)
  let delay = 1000 / FPS - msFrom(t0)
  setTimeout(process, delay)
}
process()
} catch (error) {
  console.log('navigator.MediaDevices.getUserMedia error: ', error.message, error.name);
  console.trace(error)
}
```

 */
export declare class VideoReader {
    protected video: HTMLVideoElement;
    protected canvas: HTMLCanvasElement;
    protected o: Options;
    ctx: CanvasRenderingContext2D;
    mat: Mat;
    protected size: Size;
    /**
     * Indicates if the video is currently being processed
     */
    streaming: boolean;
    protected static defaultOptions: Options;
    protected stream: MediaStream | undefined;
    constructor(video: HTMLVideoElement, canvas: HTMLCanvasElement, o?: Options);
    /**
     * reads current video frame into [mat]
     */
    read(): void;
    canPlay(): Promise<unknown>;
    stop(): void;
    protected getSize(): Size;
    private matCheck;
}
export {};
