"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var base64_1 = require("../util/base64");
var imageUtil_1 = require("../util/imageUtil");
var imageCreation_1 = require("./imageCreation");
var defaultABOptions = {};
/**
 * A sub optimal method to load a image array buffer (encoded in jpg, png) whiteouts knowing its format or size.
  * 1) creates a blob and a url object
  * * loads the url in a HTML Image (to know its dimensions )
  * * draw the image in a canvas ().
  *
  * This method is useful as a decoder for the browser without libraries
 */
function renderArrayBufferInCanvas(a, mime, options) {
    if (options === void 0) { options = defaultABOptions; }
    options = __assign(__assign({}, defaultABOptions), options);
    var url = base64_1.arrayBufferToUrl(a, mime, options.name);
    var img = new Image();
    return new Promise(function (resolve) {
        img.onload = function () {
            if (!options.canvas) {
                options.canvas = document.createElement('canvas');
                options.appendToBody && document.body.append(options.canvas);
            }
            options.canvas.setAttribute('width', img.naturalWidth + '');
            options.canvas.setAttribute('height', img.naturalHeight + '');
            options.canvas.getContext('2d').drawImage(img, 0, 0);
            resolve({ canvas: options.canvas, width: img.naturalWidth, height: img.naturalHeight });
        };
        img.onerror = function (e) {
            console.log('ERROR', e);
        };
        img.src = url;
    });
}
exports.renderArrayBufferInCanvas = renderArrayBufferInCanvas;
function renderSvgInCanvas(svg, options) {
    if (options === void 0) { options = defaultABOptions; }
    return new Promise(function (resolve) {
        var img = new Image();
        img.style.display = 'none';
        img.onerror = function (e) {
            console.log('ERROR', e);
            resolve(undefined);
        };
        img.onload = function (e) {
            if (!options.canvas) {
                options.canvas = document.createElement('canvas');
                options.appendToBody && document.body.append(options.canvas);
            }
            options.canvas.setAttribute('width', (img.width || 500) + '');
            options.canvas.setAttribute('height', (img.height || 500) + '');
            options.canvas.getContext('2d').drawImage(img, 0, 0);
            resolve({ canvas: options.canvas, width: img.naturalWidth, height: img.naturalHeight });
            img.remove();
        };
        document.body.append(img);
        img.src = base64_1.dataToUrl(svg, 'image/svg+xml', options.name || 'image.svg');
    });
}
exports.renderSvgInCanvas = renderSvgInCanvas;
var defaultOptions = {
    rgba: true,
    forceSameSize: true
};
function renderInCanvas(mat, options) {
    options = __assign(__assign({}, defaultOptions), options);
    if (!options.canvas) {
        options.canvas = document.createElement('canvas');
        options.appendToBody && !options.canvas.isConnected && document.body.append(options.canvas);
    }
    var img = options.rgba ? imageUtil_1.toRgba(mat) : mat;
    var imgData = imageCreation_1.asHtmlImageData(img);
    var ctx = options.canvas.getContext('2d');
    if (options.clear) {
        ctx.clearRect(0, 0, options.canvas.width, options.canvas.height);
    }
    if (options.forceSameSize) {
        options.canvas.width = imgData.width;
        options.canvas.height = imgData.height;
        ctx.putImageData(imgData, 0, 0, 0, 0, imgData.width, imgData.height);
    }
    else if (!options.region) {
        ctx.putImageData(imgData, 0, 0);
    }
    else {
        ctx.putImageData(imgData, options.region.x, options.region.y, options.region.x, options.region.y, options.region.width, options.region.height);
    }
    options.rgba && img.delete();
    return options.canvas;
}
exports.renderInCanvas = renderInCanvas;
//# sourceMappingURL=canvasRender.js.map